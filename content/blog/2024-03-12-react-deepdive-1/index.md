---
title: '[스터디] React Deep Dive - 1'
date: 2024-03-12
description: 'React Deep Dive - 1'
thumbnail: './thumbnail.png'
category: 'react'
isHidden: true
---

## 1. 리액트의 역사

리액트(React)는 페이스북이 개발하여 2013년에 공개한 JavaScript 라이브러리로, 사용자 인터페이스를 구축하기 위해 사용된다. 그 인기는 몇 가지 핵심 특징과 역사적 배경에 기인한다.

### **리액트의 인기 이유**

1. **단방향 데이터 흐름**: 리액트는 단방향 데이터 바인딩을 지원하여 애플리케이션의 상태 관리를 예측 가능하고 효율적으로 만든다. 이는 복잡한 애플리케이션에서 데이터 흐름을 이해하기 쉽게 만들어 준다.
2. **JSX 사용**: JSX는 HTML과 비슷한 문법을 사용하여 컴포넌트의 구조를 명시적으로 표현할 수 있게 해준다. 이는 개발자가 UI를 쉽게 이해하고 작업할 수 있게 한다.
3. **커뮤니티와 생태계**: 리액트는 강력한 커뮤니티와 광범위한 생태계를 갖추고 있어, 다양한 문제에 대한 솔루션과 라이브러리를 쉽게 찾을 수 있다.
4. **유연성**: 리액트는 UI 레이어에 집중하는 라이브러리이며, 다른 도구와 함께 사용될 때 큰 자유도를 제공한다.

### **리액트의 역사**

- **초기**: 리액트는 페이스북 내부 프로젝트로 시작되었으며, 복잡한 UI와 상호작용을 효율적으로 관리하기 위해 개발되었다.
- **공개**: 2013년에 공개된 이후 리액트는 빠르게 인기를 얻었으며, 초기에는 JSX와 같은 개념으로 인해 일부 반대 의견도 있었다.
- **발전**: 컴포넌트 기반 아키텍처와 재사용 가능한 UI 구성 요소를 통해 개발자 커뮤니티의 큰 관심을 받았다.
- **혁신**: 훅(Hooks)의 도입은 함수형 컴포넌트에서 상태 관리와 사이드 이펙트를 다루는 새로운 방법을 제공하며, 리액트의 사용성과 표현력을 크게 향상시켰다.

### **리액트의 미래**

리액트는 클라이언트 사이드 개발에 중점을 두고 있지만, 서버 사이드 렌더링(SSR)과 같은 영역에서도 계속 발전하고 있다. 이는 프론트엔드 개발자에게 서버 사이드 기술을 이해하는 것이 중요해짐을 의미한다. 리액트의 지속적인 업데이트와 개선으로 인해, 프론트엔드 개발 생태계에서 계속 중요한 역할을 할 것으로 예상된다.

이런 역사적 배경과 특성들이 리액트를 프론트엔드 개발에서 선호하는 주요 기술로 만들었으며, 개발자들 사이에서 필수 기술로 자리 잡게 했다.

## 2. 비교

자바스크립트의 데이터 타입은 크게 원시 타입과 객체 타입으로 나뉜다. 원시 타입은 불변값으로, 객체 타입은 변경 가능한 값으로 저장된다. 이 두 타입의 저장 방식 차이는 동등 비교를 할 때 중요한 역할을 한다. 객체는 참조를 저장하기 때문에, 동일한 내용을 가진 두 객체도 서로 다른 참조를 갖게 되어 동등 비교에서 **`false`**를 반환한다.

리액트에서는 동등 비교를 위해 **`Object.is`**를 사용한다. **`Object.is`**는 === 연산자와 유사하게 동작하지만, **`-0`**과 **`+0`**을 구별하거나 **`NaN`**을 자기 자신과 동일하게 취급하는 등 몇 가지 특별한 경우를 더 정확하게 처리한다. 그러나 객체 간 비교에 있어서는 **`Object.is`**도 한계가 있으므로, 리액트는 객체의 얕은 비교를 수행하는 **`shallowEqual`** 함수를 사용한다.

**`shallowEqual`**은 객체의 첫 번째 깊이의 값만을 비교하여, 객체가 포함하는 값이 동일하면 **`true`**를 반환한다. 이는 리액트의 렌더링 최적화에 중요한 역할을 한다. 예를 들어, **`React.memo`**를 사용할 때, props가 깊은 객체일 경우 얕은 비교로는 렌더링 최적화를 제대로 수행할 수 없다. 따라서 리액트에서는 가능한 깊은 객체보다는 얕은 객체를 props로 사용하는 것이 좋다.

자바스크립트의 동등 비교와 객체의 저장 방식을 이해하는 것은 리액트 개발에서 매우 중요한다. 이 지식을 바탕으로 함수 컴포넌트의 훅, **`useMemo`**, **`useCallback`**, **`React.memo`** 등을 올바르게 사용하여 렌더링 최적화를 수행할 수 있다.

## 3. 함수

자바스크립트와 리액트 개발에서 함수는 핵심적인 역할을 한다. 함수를 이해하는 것은 코드의 흐름을 파악하고, 리액트 컴포넌트를 효과적으로 작성하는 데 필수적이다. 이 글에서는 함수의 개념부터 다양한 함수 정의 방법, 주의 사항까지 살펴보았다.

### **함수의 기초**

자바스크립트에서 함수는 일정한 작업을 수행하거나 값을 계산하기 위해 사용된다. 함수는 **`function`** 키워드를 사용하여 정의되며, 매개변수를 통해 입력을 받고 **`return`** 문을 통해 결과를 반환한다. 리액트에서도 이와 같은 원칙이 컴포넌트 작성에 적용된다.

### **함수 정의 방법**

함수를 정의하는 방식은 크게 네 가지로 나눌 수 있다:

1. **함수 선언문**: 가장 기본적인 형태로, **`function`** 키워드 뒤에 함수명을 명시한다.
2. **함수 표현식**: 함수를 변수에 할당하는 방식으로, 이름이 없는 익명 함수를 주로 사용한다.
3. **Function 생성자**: **`new Function`**을 사용해 함수를 생성한다. 이 방법은 일반적으로 권장되지 않다.
4. **화살표 함수**: ES6에서 도입된 **`=>`**를 사용하는 방식으로, 간결한 문법과 **`this`** 바인딩의 차이점이 특징이다.

### **함수의 호이스팅과 `this`**

함수 선언문과 함수 표현식 사이의 주요 차이점 중 하나는 호이스팅이다. 함수 선언문은 호이스팅되어 코드의 어느 곳에서든 호출할 수 있지만, 함수 표현식은 호이스팅되지 않다. 화살표 함수는 **`this`**가 자신이 선언된 스코프의 **`this`**를 가리키는 특성이 있다.

### **함수 사용 시 주의사항**

1. **부수 효과 최소화**: 순수 함수를 작성하려고 노력하며, 불가피한 부수 효과는 명확하게 관리한다.
2. **함수의 크기**: 가능한 한 함수를 작게 만들어, 한 가지 기능만 수행하도록 한다.
3. **명확한 함수명**: 함수의 역할을 명확하게 표현하는 이름을 사용하여, 코드의 가독성과 유지 보수성을 높이다.

함수는 자바스크립트와 리액트 개발에서 매우 중요한 부분을 차지한다. 함수의 다양한 정의 방법과 특성을 이해하며, 좋은 함수를 작성하기 위한 원칙을 따르는 것이 중요한다. 이를 통해 더 효율적이고 가독성 높은 코드를 작성할 수 있다.

## 4. 클래스

자바스크립트에서 클래스는 객체를 생성하기 위한 템플릿으로 사용되며, ES6 이전에는 프로토타입을 통해 유사하게 구현되었다. 클래스를 사용하면 객체 생성 과정을 추상화하여 더 편리하게 객체를 생성할 수 있다. 자바스크립트의 클래스는 프로토타입 기반으로 작동하며, 이를 이해하면 프로토타입에 대해서도 자연스럽게 알게 된다.

### **클래스의 구성 요소**

- **constructor**: 객체를 생성하고 초기화하는 메서드이다.
- property: 객체의 속성을 정의한다.
- **getter와 setter**: 프로퍼티에 접근하고 값을 설정할 때 사용된다.
- **instance 메서드**: 객체의 인스턴스에서 사용할 수 있는 메서드이다.
- **정적 메서드**: 클래스의 인스턴스 없이 호출할 수 있는 메서드이다.

### **클래스와 함수의 관계**

클래스는 객체지향 프로그래밍 언어의 특성을 자바스크립트에 도입하기 위한 문법적 설탕으로 볼 수 있다. 클래스 내부에서 정의된 동작은 실제로는 프로토타입을 통해 구현된다. ES6 이하의 환경에서도 바벨과 같은 트랜스파일러를 사용하여 클래스를 함수로 변환하여 동일한 동작을 구현할 수 있다.

### **클래스의 중요성**

리액트 개발에서는 함수 컴포넌트의 사용이 증가하고 있지만, 기존에 클래스 기반으로 작성된 컴포넌트와 라이브러리를 이해하고 리팩터링하기 위해서는 클래스의 동작 방식을 이해하는 것이 중요한다. 또한, 클래스를 통해 생명 주기 메서드를 구현하고, 클래스 컴포넌트에서 **`this`**의 사용과 화살표 함수와 일반 함수의 차이를 이해할 수 있다.

클래스는 자바스크립트와 리액트 개발에서 객체를 효율적으로 생성하고 관리하는 방법을 제공한다. 프로토타입 기반의 동작 원리를 이해함으로써, 자바스크립트의 객체지향적 특성을 더 깊게 이해할 수 있다. 이러한 이해는 리액트에서의 클래스 컴포넌트 사용뿐만 아니라, 전반적인 자바스크립트 개발 능력 향상에도 도움이 된다.

## 5. 클로저

클로저는 함수와 그 함수가 선언된 어휘적 환경의 조합으로, 자바스크립트에서 매우 중요한 개념 중 하나이다. 리액트의 함수 컴포넌트 및 훅과 같은 고급 기능의 이해에 필수적이다. 클로저를 통해 외부 함수의 변수에 접근하고 이를 내부 함수에서 활용할 수 있는 능력을 제공한다.

### **클로저의 개념**

클로저는 함수와 그 함수가 선언된 어휘적 환경의 결합으로, 내부 함수가 외부 함수의 스코프에 접근할 수 있게 해준다. 이를 통해 외부 함수의 실행이 끝난 후에도 그 변수에 접근할 수 있다.

### **클로저의 활용**

클로저는 데이터 은닉과 캡슐화를 가능하게 한다. 이를 통해 전역 변수의 사용을 줄이고, 상태를 안전하게 변경하거나 조회할 수 있는 메커니즘을 제공한다. 예를 들어, 특정 함수의 호출 횟수를 추적하거나, 설정 값을 내부적으로 저장하는 경우 등에 활용된다.

### **클로저와 리액트**

리액트에서 클로저는 **`useState`**와 같은 훅의 내부 구현 메커니즘에 사용된다. 클로저를 통해 함수 컴포넌트 내부에서 상태 값에 접근하고, 업데이트 함수를 통해 상태를 갱신할 때 이전 상태 값을 올바르게 참조할 수 있다.

### **클로저의 주의점**

클로저의 사용은 메모리 관리 측면에서 주의를 요한다. 클로저로 인해 함수가 외부 스코프의 변수를 참조하고 있을 경우, 이 변수는 가비지 컬렉션의 대상이 되지 않아 메모리 누수가 발생할 수 있다. 따라서, 필요하지 않은 데이터는 클로저 스코프에서 제거하거나 적절히 관리해야 한다.

### **정리**

클로저는 자바스크립트와 리액트에서 중요한 역할을 하며, 함수 컴포넌트의 작동 원리와 밀접한 관련이 있다. 클로저를 통해 상태 관리, 데이터 캡슐화 등의 기능을 구현할 수 있지만, 메모리 관리에 주의해야 하는 점을 기억해야 한다. 클로저의 개념과 작동 원리를 이해하고, 적절하게 활용하는 것은 리액트 개발에 있어 필수적이다.

## 6. 이벤트 루프와 비동기통신의 이해

자바스크립트는 기본적으로 싱글 스레드 언어이며, 한 번에 하나의 작업만 처리할 수 있다. 그러나 비동기 프로그래밍을 통해 여러 작업을 동시에 처리할 수 있게 되었다. 이러한 비동기 프로그래밍의 핵심은 이벤트 루프와 태스크 큐이다.

### **싱글 스레드와 비동기 처리**

- **동기 처리**: 작업을 순차적으로 처리한다. 한 작업이 완료된 후 다음 작업이 실행된다.
- **비동기 처리**: 작업을 병렬로 처리한다. 요청을 보낸 후 응답이 오지 않아도 다음 작업을 실행할 수 있다. 이를 통해 여러 작업을 동시에 처리할 수 있다.

### **이벤트 루프**

이벤트 루프는 자바스크립트의 비동기 처리 방식을 가능하게 하는 핵심 메커니즘이다. 호출 스택이 비어 있을 때, 태스크 큐에 대기 중인 작업을 호출 스택으로 옮겨 실행하는 역할을 한다. 이 과정을 반복하며 비동기 이벤트를 처리한다.

### **태스크 큐와 마이크로 태스크 큐**

- **태스크 큐**: 비동기로 실행되어야 하는 작업들(예: setTimeout, setInterval 등)이 대기하는 곳이다.
- **마이크로 태스크 큐**: Promise 같은 더 높은 우선순위를 가진 작업들이 대기하는 곳이다. 마이크로 태스크 큐의 작업들은 태스크 큐의 작업들보다 먼저 처리된다.

### **비동기 작업의 실행 순서**

비동기 작업은 태스크 큐와 마이크로 태스크 큐를 통해 관리된다. 마이크로 태스크 큐의 작업은 모두 완료된 후에 태스크 큐의 작업이 실행된다. 이벤트 루프는 이러한 큐를 모니터링하며, 적절한 순서로 작업을 처리한다.

### **주의사항**

비동기 프로그래밍을 할 때는 메모리 관리에 주의해야 한다. 불필요한 데이터를 클로저 스코프에서 제거하거나 적절히 관리하지 않으면 메모리 누수가 발생할 수 있다. 또한, 비동기 작업의 순서와 타이밍을 정확히 예측하기 어렵기 때문에, 프로그램의 복잡도가 증가할 수 있다.

자바스크립트의 비동기 처리 메커니즘을 이해하는 것은 웹 애플리케이션 개발에 있어 매우 중요한다. 이벤트 루프와 태스크 큐를 통해 비동기 이벤트를 효율적으로 관리하고, 사용자 경험을 향상시킬 수 있다.
