---
title: 'CSS (Cascading Style Sheets)'
date: 2023-10-02
description: 'CSS-in-js 와 CSS Module의 차이 이해하기'
thumbnail: './thumbnail.png'
---

## 1. CSS-in-js

2014년 페이스북 개발자인 christopher Chedeau(vjeux)의 발표에서 CSS-in-js가 공개되었고, CSS작성의 새로운 패러다임을 제시해주었다.

### vjeux가 발표한 CSS 작성의 어려움

1. Global namespace
   - 모든 스타일을 global하게 선언하기 때문에, **별도의 class 명명 규칙을 적용해야 한다.**
2. Dependencies
   - 하나의 element에 여러 css룰이 적용되기 때문에, **모든 스타일을 개발자가 기억 해야 한다.**
3. Dead Code Elimination
   - **css가 js와 분리되어 관리**되기 때문에 **기능 변경에 따른 동기화 문제 발생**
4. Minification
   - 중복 제거를 위해 **긴 클래스 이름을 사용해 문서 사이즈가 커질** 우려
5. Sharing Constants
   - CSS가 분리돼 있어 **js의 상태 값을 공유하기 어려움**
6. Non-deterministic Resolution
   - CSS 로드 순서에 따라 우선순위가 달라지기 때문에 **CSS로드 순서를 기억** 해야 한다.
7. Isolation
   - CSS는 부모로부터 스타일을 상속하므로 **하위 component가 영향**을 받음

### CSS-in-js 도입으로 인해 생기는 이점

1. Global namespace
   - class명이 빌드 타임에 유니크하게 변경되기 때문에 별도의 **명명규칙이 필요없음**
2. Dependencies
   - CSS가 **컴포넌트 단위로 추상화되기 때문에 CSS간 의존성 고려가 필요 없음**
3. Dead Code Elimination
   - 주로 컴포넌트와 CSS가 **동일한 파일내에 존재하기 때문에 수정 및 삭제가 용이**
4. Minification
   - 빌드 타임에 짧은 길이의 **유니크한 클래스를 자동으로 생성하여 문서의 볼륨을 낮춰줌**
5. Sharing Constants
   - CSS코드가 js에 작성되므로 **컴포넌트 상태 공유가 가능**
6. Non-deterministic Resolution
   - CSS가 컴포넌트 스코프로 적용되므로 **우선순위에 따른 문제가 없음**
7. Isolation
   - CSS가 컴포넌트에 격리되어 있기 때문에 **상속 문제가 없음**

하지만 장점이 있다면 단점 또한 있기 마련이다.

위에서 언급한 내용은 대부분 **개발자 측면의 장점**이기 때문이다.

## 2. CSS Module

SSR이 필요한 리액트앱을 구축한다면 대부분 Next.js를 사용한다. Next.js는 초기부터 Styled JSX라는 자체 CSS 라이브러리는 기본으로 포함하였다.

CSS Module이 개발자의 필요에 따라 추가되었다 하지만, 달리 생각하면 CSS-in-JS 방식이 아직 온전치 못하다는 말과 같다. 그래서 많은 개발자들이 기존의 CSS방식, 또는 CSS Module과 같은 새로운 기술을 병행해서 사용한다. 테마 등의 공통 영역, 일부 유틸리티 등은 CSS-in-JS로 쉽게 해결이 어렵기 때문이다.

전통적인 CSS 방식을 사용하면, **분업이 용이하다는 장점이 있다.**

**마크업 개발자가 따로 있다면 CSS-in-JS 방식은 불편할 수 있다**. 마크업 개발자는 주로 페이지 단위로 작업하는 데 반해, 프론트엔드 개발자는 컴포넌트 단위로 작업을 한다.

프론트엔드 개발자는 마크업 개발자가 작성한 HTML과 CSS를 받아 컴포넌트 단위로 재구성을 해야한다. CSS-in-JS 방식을 사용한다면, 이미 만들어 놓은 코드를 재배치해야 하기 때문에 효율이 떨어진다.

유지보수에도 계속 영향을 끼칠 수밖에 없다.

## 3. CSS-in-JS vs CSS Module

동일한 화면을 두 방식으로 작성해 비교하는 글을 보았는데.

동일 화면이기 때문에, Rendering 과 Painting 소요시간은 크게 다르지 않다. 반면 **Scripting은 2배 가까운 성능 차이가 보인다.** CSS-in-JS 방식은 CSS코드를 변환하는 과정이 필요하기 때문이다.

**빌드 타임에 모든 CSS가 만들어진다면 모르겠지만, 동적으로 CSS가 추가되는 구조라면 아무래도 느릴 수 밖에 없다.** 물론 CSS Module역시 CSS코드가 js번들에 포함되어 있지만 온전한 CSS 형태를 유지하고 있기에 Styled-components에 비해 짧은 시간에 화면을 그릴 수 있다.

## 4. tailwind

디자인 요소가 중요한 서비스는 디자이너와 협업의 비중이 크다. 테마 같은 디자인 시스템이 구축되어 있지 않다면 빠르게 변하는 디자인을 적용하는데 효울이 떨어진다. 게다가 공통으로 사용하는 유틸리티 코드를 따로 만들어야 한다.

과거에는 디자인 시스템을 위한 대표적인 CSS 프레임워크인 부트스트랩이 있었다.

미리 만들어진 구성요소를 편리하게 사용할 수 있었다.

하지만 부트스트랩은 확장성이 떨어진다. 미리 만들어진 구성요소로만 서비스를 구축해야 하기 때문이다.

게다가 사용하지 않는 요소까지 CSS/JS에 포함되어 번들이 커지는 단점도 있다.

테일윈드는 부트스트랩의 단점을 해결해 준다. 사용자의 필요에 따라 거의 모든 CSS를 작성할 수 있다.

그리고 디자인 시스템도 구축 가능하다. 또한 **빌드 시, 사용하지 않는 클래스가 제거되어 번들 크기가 최소로 유지**된다.

하지만 단점도 존재한다.

tailwind는 **rem 단위가 기본**이기 때문에, **px 단위 서비스라면 기본값을 바꿔줘야 한다.**

그리고 **빌드 타임에 모두 생성되므로 동적 변수를 사용할 수 없는 문제가 있다.**

**애니메이션과 트랜지션 사용에 제약**이 있다.

## 5. 마무리

마크업과 JS를 모두 작성하는 소규모 팀에서는 CSS-in-JS 방식이 유용하다.

초기에는 빠르게 작성하고 빠르게 테스트하는 것이 중요하기 때문이다.

하지만 어느정도 규모있고 안정적인 서비스를 구축한다면 CSS Module이나 tailwind 같은 유틸리티 CSS가 성능 측면에서 좋을것 같다.
